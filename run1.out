
R version 3.0.2 (2013-09-25) -- "Frisbee Sailing"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("msnet_simu_fun2.R")
> library(Rmpi)
> library(snow)
> 
> cl=makeCluster(30)
	30 slaves are spawned successfully. 0 failed.
> clusterEvalQ(cl,{library(Matrix);source("senet.R");source("utils.R")})
[[1]]
[[1]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[19]]$visible
[1] FALSE


[[20]]
[[20]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[20]]$visible
[1] FALSE


[[21]]
[[21]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[21]]$visible
[1] FALSE


[[22]]
[[22]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[22]]$visible
[1] FALSE


[[23]]
[[23]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[23]]$visible
[1] FALSE


[[24]]
[[24]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[24]]$visible
[1] FALSE


[[25]]
[[25]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[25]]$visible
[1] FALSE


[[26]]
[[26]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[26]]$visible
[1] FALSE


[[27]]
[[27]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[27]]$visible
[1] FALSE


[[28]]
[[28]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[28]]$visible
[1] FALSE


[[29]]
[[29]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[29]]$visible
[1] FALSE


[[30]]
[[30]]$value
function (data, ctr = ctr, jobid = 0, df) 
{
    Data = list(X = as.matrix(bdiag(data$X)), y = c(data$Y), 
        beta = c(data$B), X_test = as.matrix(bdiag(data$X_test)), 
        y_test = c(data$Y_test), p1x = data$p1x, p2x = data$p2x, 
        p1y = data$p1y, p2y = data$p2y)
    px = dim(data$B)[1]
    py = dim(data$B)[2]
    n = dim(data$X[[1]])[1]
    n_test = dim(data$X_test[[1]])[1]
    lx = ctr$lx
    ly = ctr$ly
    muy = ctr$muy
    if (lx == "1d") {
        Lpx = crossprod(fd(px))
    }
    else if (lx == "2d") {
        Lpx = genlap(p1x, p2x)$L
    }
    else if (lx == "cor") {
        Lpx = cor(data$X[[1]])
    }
    if (lx == "1d") {
        Lpy = crossprod(fd(py))
    }
    else if (lx == "2d") {
        Lpy = genlap(p1y, p2y)$L
    }
    else if (lx == "cor") {
        Lpy = cor(data$Y)
    }
    Lx = kronecker(Lpx, diag(rep(1, py)))
    Ly = kronecker(Lpy, diag(rep(1, px)))
    P = matrix(0, px * py, px * py)
    for (i in 1:px) {
        for (j in 1:py) {
            P[(i - 1) * py + j, (j - 1) * px + i] = 1
        }
    }
    Lx = t(P) %*% Lx %*% P
    Lambda = muy * Ly + (1 - muy) * Lx
    lambda1 = ctr$lambda1
    lambda2 = ctr$lambda2
    stepsize = ctr$stepsize
    ctr$L = ifelse(stepsize == "fixed", Ll2(Data$X, Lambda, lambda2 = lambda2), 
        NULL)
    out = senet_fista(Data$X, Data$y, Lambda, lossfun = l2loss, 
        gradfun = l2grad, lambda1 = lambda1, lambda2 = lambda2, 
        stepsize = stepsize, control = ctr)
    Bhat = matrix(out$beta, byrow = FALSE, nrow = px, ncol = py)
    Y_test_hat = as.matrix(bdiag(Data$X_test)) %*% (out$beta)
    E_test = sqrt(mean((c(Data$y_test) - Y_test_hat)^2))
    slist = list(fit = out, input = list(B = data$B, px = px, 
        py = py, n = n, Lambda = Lambda, lambda1 = lambda1, lambda2 = lambda2, 
        muy = muy), output = list(Bhat = Bhat, rmse_test = E_test, 
        Y_test = Data$y_test, Y_test_hat = Y_test_hat, obj = out$obj))
    fname = paste0("./results/n", n, "px", px, "py", py, "job", 
        jobid)
    save(slist, file = paste0(fname, ".RData"))
    return()
}

[[30]]$visible
[1] FALSE


> clusterExport(cl,c("ctr","c1","df")) #clusterCall(cl,print,a+b)
> clusterApplyLB(cl, 1:nrow(df), simu,ctr,c1,df)
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL

[[6]]
NULL

[[7]]
NULL

[[8]]
NULL

[[9]]
NULL

[[10]]
NULL

[[11]]
NULL

[[12]]
NULL

[[13]]
NULL

[[14]]
NULL

[[15]]
NULL

> stopCluster(cl)
[1] 1
> 
> save(ctr,c1,df,file = "./results/df.RData")
> 
--------------------------------------------------------------------------
mpirun has exited due to process rank 0 with PID 42470 on
node compute-0-081 exiting improperly. There are three reasons this could occur:

1. this process did not call "init" before exiting, but others in
the job did. This can cause a job to hang indefinitely while it waits
for all processes to call "init". By rule, if one process calls "init",
then ALL processes must call "init" prior to termination.

2. this process called "init", but exited without calling "finalize".
By rule, all processes that call "init" MUST call "finalize" prior to
exiting or it will be considered an "abnormal termination"

3. this process called "MPI_Abort" or "orte_abort" and the mca parameter
orte_create_session_dirs is set to false. In this case, the run-time cannot
detect that the abort call was an abnormal termination. Hence, the only
error message you will receive is this one.

This may have caused other processes in the application to be
terminated by signals sent by mpirun (as reported here).

You can avoid this message by specifying -quiet on the mpirun command line.

--------------------------------------------------------------------------
