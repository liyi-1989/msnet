py=20
n=100
B=matrix(0,px,py)
Y=matrix(0,n,py)
X=matrix(0,n,px)
X=list(py)
P=matrix(0,px*py,px*py)
for(i in 1:px){
for(j in 1:py){
P[(i-1)*py+j,(j-1)*px+i]=1 # Permutation matrix
}
}
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = 100, p=100, noise.signal = 0.25, noise.response = 10, B[,i])
Y[,i]=data$y
X[[i]]=data$Xt
}
# Block to long
y=c(Y) # npy*1
#Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
Xt=as.matrix(bdiag(X))
beta=c(B) # pxpy
data=list(Xt = Xt, y=y, beta = beta)
GL=crossprod( fd(px*py) )
#------------------------------
Lambda = GL
L <- Ll2(Xt, Lambda, lambda2 = 10) ### fixed step-size
out <- senet_fista(data$Xt, data$y, Lambda, lossfun = l2loss, gradfun = l2grad, lambda1 = 10^4, lambda2 = 10,
stepsize = "fixed",
control = list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9))
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
#------------------------------
Lambda = GL+ t(P)%*%GL%*%P
L <- Ll2(Xt, Lambda, lambda2 = 10) ### fixed step-size
out2 <- senet_fista(data$Xt, data$y, Lambda, lossfun = l2loss, gradfun = l2grad, lambda1 = 10^4, lambda2 = 10,
stepsize = "fixed",
control = list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9))
Bhat2=matrix(out2$beta,byrow = FALSE,nrow = px, ncol = py)
norm(B-Bhat,"2")
norm(B-Bhat2,"2")
norm(B-Bhat,"F")
norm(B-Bhat2,"F")
image(B)
norm(B-Bhat,"F")
image(Bhat)
norm(B-Bhat2,"F")
image(Bhat2)
Lambda = GL
L <- Ll2(Xt, Lambda, lambda2 = 10) ### fixed step-size
Lambda2 = GL+ t(P)%*%GL%*%P
L2 <- Ll2(Xt, Lambda2, lambda2 = 10) ### fixed step-size
#------------------------------
out <- senet_fista(data$Xt, data$y, Lambda, lossfun = l2loss, gradfun = l2grad, lambda1 = 10, lambda2 = 10,
stepsize = "fixed",
control = list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9))
?norm
base::norm(a)
a
base::norm(a,"2")
Matrix::norm(a,"2")
source("senet.R")
Lambda = GL
L <- Ll2(Xt, Lambda, lambda2 = 10) ### fixed step-size
Lambda2 = GL+ t(P)%*%GL%*%P
L2 <- Ll2(Xt, Lambda2, lambda2 = 10) ### fixed step-size
#------------------------------
out <- senet_fista(data$Xt, data$y, Lambda, lossfun = l2loss, gradfun = l2grad, lambda1 = 10, lambda2 = 10,
stepsize = "fixed",
control = list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9))
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
#------------------------------
out2 <- senet_fista(data$Xt, data$y, Lambda2, lossfun = l2loss, gradfun = l2grad, lambda1 = 10, lambda2 = 10,
stepsize = "fixed",
control = list(L = L2,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9))
Bhat2=matrix(out2$beta,byrow = FALSE,nrow = px, ncol = py)
image(B)
norm(B-Bhat,"F")
image(Bhat)
norm(B-Bhat2,"F")
image(Bhat2)
plot(out$obj)
plot(out2$obj)
norm(B-Bhat,"M")
norm(B-Bhat2,"M")
out
str(out)
6789%%10
6789/10
floor(6789/10)
6789%%floor(6789/10)
6789%%floor(6789/10)==0
library(Matrix)
source("senet.R")
paras=list(
px=100,
py=20,
n=100,
lambda1=10,
lambda2=10,
noise.signal = 0.25,
noise.response = 10
)
GL=crossprod( fd(px*py) )
Lambda = GL
L = Ll2(Xt, Lambda, lambda2 = lambda2) ### fixed step-size
ctr=list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9)
Lambda2 = GL+ t(P)%*%GL%*%P
L2 <- Ll2(Xt, Lambda2, lambda2 = lambda2) ### fixed step-size
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
ctr$L=L
res1=simu(paras,ctr,Lambda,L)
k=567
(k%%floor(k/10) == 0
)
k%%floor(k/10) == 0
k=0
k%%floor(k/10) == 0
floor(0/10)
0%%0
0%%0<1
0%%0
source("senet.R")
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
res1=simu(paras,ctr,Lambda,L)
source("senet.R")
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
res1=simu(paras,ctr,Lambda,L)
1%%0
source("senet.R")
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
res1=simu(paras,ctr,Lambda,L)
source("senet.R")
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
res1=simu(paras,ctr,Lambda,L)
source("senet.R")
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
res1=simu(paras,ctr,Lambda,L)
source("senet.R")
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
(60 < t && t < 80)*((70 - t)^2-100)/200)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
res1=simu(paras,ctr,Lambda,L)
ctr$L=L2
res2=simu(paras,ctr,Lambda2,L2)
sum(res1$B!=res2$B)
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat2,"F")
image(res2$Bhat2)
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat2)
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat)
plot(betastar)
plot(sin(2*pi*(1:100)/5))
plot(1:100,sin(2*pi*(1:100)/5))
plot(sin(2*pi*(1:100)/500))
plot(sin(2*pi*(1:500)/500))
library(Matrix)
source("senet.R")
paras=list(
px=20,
py=20,
n=500,
lambda1=10,
lambda2=10,
noise.signal = 0.25,
noise.response = 10
)
GL=crossprod( fd(px*py) )
Lambda = GL
L = Ll2(Xt, Lambda, lambda2 = lambda2) ### fixed step-size
ctr=list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9)
Lambda2 = GL+ t(P)%*%GL%*%P
L2 <- Ll2(Xt, Lambda2, lambda2 = lambda2) ### fixed step-size
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
# betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
#                      (60 < t && t < 80)*((70 - t)^2-100)/200)
betastar=sin(2*pi*(1:px)/px)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
ctr$L=L
res1=simu(paras,ctr,Lambda,L)
ctr$L=L2
res2=simu(paras,ctr,Lambda2,L2)
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat)
library(Matrix)
source("senet.R")
paras=list(
px=20,
py=20,
n=500,
lambda1=10,
lambda2=10,
noise.signal = 0.25,
noise.response = 10
)
GL=crossprod( fd(paras$px*paras$py) )
Lambda = GL
L = Ll2(Xt, Lambda, lambda2 = paras$lambda2) ### fixed step-size
ctr=list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9)
Lambda2 = GL+ t(P)%*%GL%*%P
L2 <- Ll2(Xt, Lambda2, lambda2 = lambda2) ### fixed step-size
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
# betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
#                      (60 < t && t < 80)*((70 - t)^2-100)/200)
betastar=sin(2*pi*(1:px)/px)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
ctr$L=L
res1=simu(paras,ctr,Lambda,L)
ctr$L=L2
res2=simu(paras,ctr,Lambda2,L2)
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat)
library(Matrix)
source("senet.R")
paras=list(
px=20,
py=20,
n=500,
lambda1=10,
lambda2=10,
noise.signal = 0.25,
noise.response = 10
)
GL=crossprod( fd(paras$px*paras$py) )
Lambda = GL
L = Ll2(Xt, Lambda, lambda2 = paras$lambda2) ### fixed step-size
ctr=list(L = L,
use.gram = TRUE,
maxiter = 10000,
tol = 1e-8,
init = NULL,
sigma = 0.9)
Lambda2 = GL+ t(P)%*%GL%*%P
L2 <- Ll2(Xt, Lambda2, lambda2 = paras$lambda2) ### fixed step-size
simu=function(paras,ctr,Lambda,L,stepsize = "fixed"){
cat("1. Set Parameters ...\n")
px=paras$px; py=paras$py; n=paras$n; B=matrix(0,px,py); Y=matrix(0,n,py); X=matrix(0,n,px); X=list(py); P=matrix(0,px*py,px*py)
lambda1=paras$lambda1; lambda2=paras$lambda2; noise.signal = paras$noise.signal; noise.response = paras$noise.response
for(i in 1:px){ for(j in 1:py){ P[(i-1)*py+j,(j-1)*px+i]=1 } } # Permutation matrix
cat("2. Generate Data ...\n")
# betastar <- sapply(1:px, function(t) (20 < t && t < 40)*((-1)*(30 - t)^2+100)/200 +
#                      (60 < t && t < 80)*((70 - t)^2-100)/200)
betastar=sin(2*pi*(1:px)/px)
for(i in 1:py){
B[,i]=betastar[(1:px-i)%%px+1]
data <- simblock1d(n = n, p=px, noise.signal = noise.signal, noise.response = noise.response, B[,i])
Y[,i]=data$y; X[[i]]=data$Xt
}
# Block to long
data=list(Xt=as.matrix(bdiag(X)), y=c(Y), beta = c(B)) #Xt=bdiag(lapply(1:py,function(dumy,a){a},X)) # same X # npy*pxpy
cat("3. Fit the model ...\n")
out = senet_fista(data$Xt, data$y, Lambda, lossfun=l2loss, gradfun=l2grad, lambda1=lambda1, lambda2=lambda2, stepsize=stepsize, control = ctr)
Bhat=matrix(out$beta,byrow = FALSE,nrow = px, ncol = py)
return(list(fit=out,B=B,Bhat=Bhat,px=px,py=py,n=n,Lambda=Lambda))
}
ctr$L=L
res1=simu(paras,ctr,Lambda,L)
ctr$L=L2
res2=simu(paras,ctr,Lambda2,L2)
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat)
a=list(b=3)
a=list(c=8=3)
a=list(c=8)
a
a=list(b=3)
a
source('D:/works/msenet/msnet_simu.R')
source('D:/works/msenet/msnet_simu.R')
source('D:/works/msenet/msnet_simu.R')
source('D:/works/msenet/msnet_simu.R')
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat)
source('D:/works/msenet/msnet_simu.R')
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat)
source('D:/works/msenet/msnet_simu.R')
image(res1$B)
norm(res1$B-res1$Bhat,"F")
image(res1$Bhat)
norm(res2$B-res2$Bhat,"F")
image(res2$Bhat)
